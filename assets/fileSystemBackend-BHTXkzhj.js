var w=Object.defineProperty;var F=(l,e,t)=>e in l?w(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var y=(l,e,t)=>F(l,typeof e!="symbol"?e+"":e,t);import{aQ as a}from"./index-BqzSlmqz.js";const h="1.0";class S{constructor(){y(this,"type","filesystem");y(this,"directoryHandle",null);y(this,"initialized",!1)}async isAvailable(){return typeof window<"u"&&"showDirectoryPicker"in window}async initialize(){try{a.info("[FileSystemBackend] Requesting directory access..."),this.directoryHandle=await window.showDirectoryPicker({mode:"readwrite",startIn:"documents"}),this.initialized=!0,a.info("[FileSystemBackend] Initialized successfully")}catch(e){throw a.error("[FileSystemBackend] Failed to initialize:",e),new Error("Failed to initialize FileSystemBackend: User may have denied access")}}async readNota(e){var t;this.ensureInitialized();try{const n=[".nota",".json"];for(const r of n)try{const s=`${e.replace(/[^a-zA-Z0-9-_]/g,"_")}${r}`,d=await(await(await this.directoryHandle.getFileHandle(s,{create:!1})).getFile()).text(),f=JSON.parse(d),c=f.nota||f;return c.createdAt&&(c.createdAt=new Date(c.createdAt)),c.updatedAt&&(c.updatedAt=new Date(c.updatedAt)),a.debug(`[FileSystemBackend] Read nota: ${e} from ${s}`),c}catch(i){if(i.name==="NotFoundError"||(t=i.message)!=null&&t.includes("NotFoundError"))continue;throw i}return null}catch(n){return a.error(`[FileSystemBackend] Failed to read nota ${e}:`,n),null}}async writeNota(e){this.ensureInitialized();try{const t=this.getNotaFileName(e.id),r=await(await this.directoryHandle.getFileHandle(t,{create:!0})).createWritable(),i={version:h,exportedAt:new Date().toISOString(),nota:e},s=JSON.stringify(i,null,2);await r.write(s),await r.close(),a.debug(`[FileSystemBackend] Wrote nota: ${e.id}`)}catch(t){throw a.error(`[FileSystemBackend] Failed to write nota ${e.id}:`,t),t}}async deleteNota(e){var t;this.ensureInitialized();try{const n=e.replace(/[^a-zA-Z0-9-_]/g,"_"),r=[".nota",".json"];let i=!1;for(const s of r)try{const o=`${n}${s}`;await this.directoryHandle.removeEntry(o),a.debug(`[FileSystemBackend] Deleted nota: ${e} (${o})`),i=!0}catch(o){if(o.name==="NotFoundError"||(t=o.message)!=null&&t.includes("NotFoundError"))continue;throw o}i||a.debug(`[FileSystemBackend] Nota file not found: ${e} (already deleted or never existed)`)}catch(n){throw a.error(`[FileSystemBackend] Failed to delete nota ${e}:`,n),n}}async listNotas(){this.ensureInitialized();const e=[];try{const t=this.directoryHandle;for await(const[n,r]of t.entries())if(r.kind==="file"&&(n.endsWith(".nota")||n.endsWith(".json")))try{const o=await(await r.getFile()).text(),u=JSON.parse(o),d=u.nota||u;d.createdAt&&(d.createdAt=new Date(d.createdAt)),d.updatedAt&&(d.updatedAt=new Date(d.updatedAt)),e.push(d)}catch{a.warn(`[FileSystemBackend] Failed to parse file ${r.name}, skipping`)}return a.debug(`[FileSystemBackend] Listed ${e.length} notas`),e}catch(t){return a.error("[FileSystemBackend] Failed to list notas:",t),[]}}ensureInitialized(){if(!this.initialized||!this.directoryHandle)throw new Error("FileSystemBackend not initialized. Call initialize() first.")}getNotaFileName(e){return`${e.replace(/[^a-zA-Z0-9-_]/g,"_")}.nota`}async watchDirectory(e){this.ensureInitialized();try{a.info("[FileSystemBackend] Directory watching not yet implemented")}catch(t){a.error("[FileSystemBackend] Failed to watch directory:",t)}}async readNotaFile(e){try{const n=await(await e.getFile()).text(),r=JSON.parse(n),i=r.nota||r;return i.createdAt&&(i.createdAt=new Date(i.createdAt)),i.updatedAt&&(i.updatedAt=new Date(i.updatedAt)),a.debug(`[FileSystemBackend] Read .nota file: ${i.id}`),i}catch(t){return a.error("[FileSystemBackend] Failed to read .nota file:",t),null}}getDirectoryHandle(){return this.directoryHandle}}export{S as FileSystemBackend};
