var m=Object.defineProperty;var F=(c,e,t)=>e in c?m(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var y=(c,e,t)=>F(c,typeof e!="symbol"?e+"":e,t);import{az as i}from"./index-DIg-grGt.js";import{g as u,v as w,s as p}from"./directoryHandleStorage-CPjZxu3I.js";const g="1.0";class z{constructor(){y(this,"type","filesystem");y(this,"directoryHandle",null);y(this,"initialized",!1)}static async hasPersistedHandle(){try{return await u()!==null}catch{return!1}}async isAvailable(){return typeof window<"u"&&"showDirectoryPicker"in window}async initialize(){try{i.info("[FileSystemBackend] Attempting to initialize with persisted handle...");const e=await u();if(!e)throw i.warn("[FileSystemBackend] No persisted directory handle found"),new Error("No directory handle available. User must select a directory first.");if(!await w(e))throw i.warn("[FileSystemBackend] Permission denied for persisted directory handle"),new Error("Permission denied for directory. User must grant access again.");this.directoryHandle=e,this.initialized=!0,i.info("[FileSystemBackend] Initialized successfully with persisted handle")}catch(e){throw i.error("[FileSystemBackend] Failed to initialize:",e),e}}async readNota(e){var t;this.ensureInitialized();try{const r=[".nota",".json"];for(const n of r)try{const d=`${e.replace(/[^a-zA-Z0-9-_]/g,"_")}${n}`,s=await(await(await this.directoryHandle.getFileHandle(d,{create:!1})).getFile()).text(),h=JSON.parse(s),l=h.nota||h;return l.createdAt&&(l.createdAt=new Date(l.createdAt)),l.updatedAt&&(l.updatedAt=new Date(l.updatedAt)),i.debug(`[FileSystemBackend] Read nota: ${e} from ${d}`),l}catch(a){if(a.name==="NotFoundError"||(t=a.message)!=null&&t.includes("NotFoundError"))continue;throw a}return null}catch(r){return i.error(`[FileSystemBackend] Failed to read nota ${e}:`,r),null}}async writeNota(e){this.ensureInitialized();try{const t=this.getNotaFileName(e.id),n=await(await this.directoryHandle.getFileHandle(t,{create:!0})).createWritable(),a={version:g,exportedAt:new Date().toISOString(),nota:e},d=JSON.stringify(a,null,2);await n.write(d),await n.close(),i.debug(`[FileSystemBackend] Wrote nota: ${e.id}`)}catch(t){throw i.error(`[FileSystemBackend] Failed to write nota ${e.id}:`,t),t}}async deleteNota(e){var t;this.ensureInitialized();try{const r=e.replace(/[^a-zA-Z0-9-_]/g,"_"),n=[".nota",".json"];let a=!1;for(const d of n)try{const o=`${r}${d}`;await this.directoryHandle.removeEntry(o),i.debug(`[FileSystemBackend] Deleted nota: ${e} (${o})`),a=!0}catch(o){if(o.name==="NotFoundError"||(t=o.message)!=null&&t.includes("NotFoundError"))continue;throw o}a||i.debug(`[FileSystemBackend] Nota file not found: ${e} (already deleted or never existed)`)}catch(r){throw i.error(`[FileSystemBackend] Failed to delete nota ${e}:`,r),r}}async listNotas(){this.ensureInitialized();const e=[];try{const t=this.directoryHandle;for await(const[r,n]of t.entries())if(n.kind==="file"&&(r.endsWith(".nota")||r.endsWith(".json")))try{const o=await(await n.getFile()).text(),f=JSON.parse(o),s=f.nota||f;s.createdAt&&(s.createdAt=new Date(s.createdAt)),s.updatedAt&&(s.updatedAt=new Date(s.updatedAt)),e.push(s)}catch{i.warn(`[FileSystemBackend] Failed to parse file ${n.name}, skipping`)}return i.debug(`[FileSystemBackend] Listed ${e.length} notas`),e}catch(t){return i.error("[FileSystemBackend] Failed to list notas:",t),[]}}ensureInitialized(){if(!this.initialized||!this.directoryHandle)throw new Error("FileSystemBackend not initialized. Call initialize() first.")}getNotaFileName(e){return`${e.replace(/[^a-zA-Z0-9-_]/g,"_")}.nota`}async watchDirectory(e){this.ensureInitialized();try{i.info("[FileSystemBackend] Directory watching not yet implemented")}catch(t){i.error("[FileSystemBackend] Failed to watch directory:",t)}}async readNotaFile(e){try{const r=await(await e.getFile()).text(),n=JSON.parse(r),a=n.nota||n;return a.createdAt&&(a.createdAt=new Date(a.createdAt)),a.updatedAt&&(a.updatedAt=new Date(a.updatedAt)),i.debug(`[FileSystemBackend] Read .nota file: ${a.id}`),a}catch(t){return i.error("[FileSystemBackend] Failed to read .nota file:",t),null}}getDirectoryHandle(){return this.directoryHandle}async setDirectoryHandle(e){try{if(!await w(e))throw new Error("Permission denied for directory");await p(e),this.directoryHandle=e,this.initialized=!0,i.info("[FileSystemBackend] Directory handle set and persisted")}catch(t){throw i.error("[FileSystemBackend] Failed to set directory handle:",t),t}}}export{z as FileSystemBackend};
