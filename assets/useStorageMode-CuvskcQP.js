var k=Object.defineProperty;var x=(n,e,r)=>e in n?k(n,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):n[e]=r;var p=(n,e,r)=>x(n,typeof e!="symbol"?e+"":e,r);import{aQ as o,P as F,q as A}from"./index-dr6P1g6z.js";class C{constructor(e){p(this,"backend",null);p(this,"isWatching",!1);p(this,"pollInterval",2e3);p(this,"intervalId",null);p(this,"fileSnapshots",new Map);p(this,"options",{});this.options=e||{},this.pollInterval=(e==null?void 0:e.pollInterval)||2e3}setBackend(e){this.backend=e}async start(){if(this.isWatching){o.warn("[FileWatcher] Already watching");return}if(!this.backend)throw new Error("FileWatcherService: Backend not set");o.info("[FileWatcher] Starting file watcher..."),this.isWatching=!0,await this.takeSnapshot(),this.intervalId=setInterval(async()=>{var e,r;try{await this.checkForChanges()}catch(h){o.error("[FileWatcher] Error checking for changes:",h),(r=(e=this.options).onError)==null||r.call(e,h)}},this.pollInterval),o.info(`[FileWatcher] Started watching (polling every ${this.pollInterval}ms)`)}stop(){this.isWatching&&(o.info("[FileWatcher] Stopping file watcher..."),this.isWatching=!1,this.intervalId&&(clearInterval(this.intervalId),this.intervalId=null),this.fileSnapshots.clear(),o.info("[FileWatcher] File watcher stopped"))}isActive(){return this.isWatching}async takeSnapshot(){if(!this.backend)return;const e=this.backend.getDirectoryHandle();if(e)try{const r=new Map,h=e;for await(const[c,f]of h.entries())if(f.kind==="file"&&(c.endsWith(".nota")||c.endsWith(".json")))try{const u=await f.getFile(),l=c.replace(/\.(nota|json)$/,"").replace(/_/g,"-");r.set(c,{name:c,notaId:l,lastModified:u.lastModified,size:u.size})}catch(g){o.warn(`[FileWatcher] Failed to read file ${c}:`,g)}this.fileSnapshots=r,o.debug(`[FileWatcher] Snapshot taken: ${this.fileSnapshots.size} files`)}catch(r){throw o.error("[FileWatcher] Failed to take snapshot:",r),r}}async checkForChanges(){var r,h,c,f,g,u;if(!this.backend)return;const e=this.backend.getDirectoryHandle();if(e)try{const l=new Map,w=[],y=[],v=e;for await(const[t,i]of v.entries())if(i.kind==="file"&&(t.endsWith(".nota")||t.endsWith(".json")))try{const M=await i.getFile(),$=t.replace(/\.(nota|json)$/,"").replace(/_/g,"-"),S={name:t,notaId:$,lastModified:M.lastModified,size:M.size};l.set(t,S);const m=this.fileSnapshots.get(t);m?(m.lastModified!==S.lastModified||m.size!==S.size)&&w.push(t):y.push(t)}catch(a){o.warn(`[FileWatcher] Failed to read file ${t}:`,a)}const W=[];for(const[t,i]of this.fileSnapshots.entries())l.has(t)||W.push(t);if(this.fileSnapshots=l,w.length>0){o.info(`[FileWatcher] Files changed: ${w.join(", ")}`);for(const t of w){const i=l.get(t);if(i)try{const a=await this.backend.readNota(i.notaId);a&&((h=(r=this.options).onFileChanged)==null||h.call(r,i.notaId,a))}catch(a){o.error(`[FileWatcher] Failed to read changed file ${t}:`,a)}}}if(y.length>0){o.info(`[FileWatcher] Files added: ${y.join(", ")}`);for(const t of y){const i=l.get(t);if(i)try{const a=await this.backend.readNota(i.notaId);a&&((f=(c=this.options).onFileAdded)==null||f.call(c,i.notaId,a))}catch(a){o.error(`[FileWatcher] Failed to read added file ${t}:`,a)}}}if(W.length>0){o.info(`[FileWatcher] Files deleted: ${W.join(", ")}`);for(const t of W){const i=this.fileSnapshots.get(t);i&&((u=(g=this.options).onFileDeleted)==null||u.call(g,i.notaId))}}}catch(l){throw o.error("[FileWatcher] Failed to check for changes:",l),l}}setPollInterval(e){this.pollInterval=e,this.isWatching&&(this.stop(),this.start().catch(r=>{o.error("[FileWatcher] Failed to restart with new interval:",r)}))}getPollInterval(){return this.pollInterval}}let I=null;function z(n){return I||(I=new C(n)),I}const H="bashnota-storage-mode";let s=null;function j(){try{const n=localStorage.getItem(H);if(n){const e=JSON.parse(n);return{mode:e.mode||"indexeddb",autoWatch:e.autoWatch??!0,directoryHandle:null}}}catch(n){o.error("Failed to load storage mode config:",n)}return{mode:"indexeddb",autoWatch:!0,directoryHandle:null}}function D(n){try{const e={mode:n.mode,autoWatch:n.autoWatch};localStorage.setItem(H,JSON.stringify(e)),o.info("[StorageMode] Configuration saved:",e)}catch(e){o.error("Failed to save storage mode config:",e)}}const d=A(j());function b(){const n=F({get:()=>d.value.mode,set:t=>{d.value.mode=t,D(d.value),o.info("[StorageMode] Mode changed to:",t)}}),e=F({get:()=>d.value.autoWatch,set:t=>{d.value.autoWatch=t,D(d.value),o.info("[StorageMode] Auto-watch changed to:",t),s&&(t&&d.value.mode==="filesystem"?s.start().catch(i=>{o.error("[StorageMode] Failed to start file watcher:",i)}):s.stop())}}),r=F(()=>typeof window<"u"&&"showDirectoryPicker"in window),h=F(()=>d.value.mode==="filesystem"),c=F(()=>d.value.mode==="indexeddb"),f=F(()=>(s==null?void 0:s.isActive())||!1),g=async()=>{if(!r.value)throw new Error("File System Access API is not supported in this browser");n.value="filesystem",o.info("[StorageMode] Switched to filesystem mode")},u=()=>{n.value="indexeddb",s&&s.stop(),o.info("[StorageMode] Switched to IndexedDB mode")},l=t=>{d.value.directoryHandle=t,o.info("[StorageMode] Directory handle updated")},w=()=>d.value.directoryHandle,y=(t,i)=>(s||(s=z({pollInterval:2e3,onFileChanged:i==null?void 0:i.onFileChanged,onFileAdded:i==null?void 0:i.onFileAdded,onFileDeleted:i==null?void 0:i.onFileDeleted,onError:a=>{o.error("[StorageMode] File watcher error:",a)}})),s.setBackend(t),d.value.mode==="filesystem"&&d.value.autoWatch&&s.start().catch(a=>{o.error("[StorageMode] Failed to start file watcher:",a)}),s),v=()=>{s&&s.stop()},W=F(()=>{switch(d.value.mode){case"filesystem":return"Files are stored directly in a selected folder as .nota files. Changes to files in the folder are reflected in real-time.";case"indexeddb":return"Files are stored in the browser's IndexedDB. Data is stored locally in the browser.";default:return"Unknown storage mode"}});return{storageMode:n,autoWatch:e,isFilesystemSupported:r,isFilesystemMode:h,isIndexedDBMode:c,isWatchingFiles:f,getModeDescription:W,switchToFilesystem:g,switchToIndexedDB:u,setDirectoryHandle:l,getDirectoryHandle:w,initializeFileWatcher:y,stopFileWatcher:v}}export{b as u};
