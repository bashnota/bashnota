import { BaseActor } from './BaseActor'
import { ActorType, type VibeTask } from '@/types/vibe'
import { DatabaseEntryType } from '@/types/vibe'

/**
 * Result from the Planner actor
 */
export interface PlannerResult {
  plan: TaskPlan
  summary: string
}

/**
 * Task plan created by the Planner
 */
export interface TaskPlan {
  tasks: PlannedTask[]
  mainGoal: string
}

/**
 * Task planned by the Planner
 */
export interface PlannedTask {
  title: string
  description: string
  actorType: ActorType
  dependencies: string[] // IDs of tasks this task depends on
  priority: 'high' | 'medium' | 'low'
  estimatedCompletion: 'short' | 'medium' | 'long'
}

/**
 * The Planner actor - responsible for creating task plans
 */
export class Planner extends BaseActor {
  constructor() {
    super(ActorType.PLANNER)
  }

  /**
   * Execute the Planner actor
   * @param task The planning task
   * @returns The planning result
   */
  protected async execute(task: VibeTask): Promise<PlannerResult> {
    // Create a "plans" table for storing planning data
    const plansTable = this.createTable(
      task.boardId,
      'plans',
      'Contains planning data for tasks',
      {
        mainGoal: 'string',
        tasks: 'array',
        summary: 'string'
      }
    )
    
    // Create a prompt for the AI to generate a plan
    const prompt = this.createPlanningPrompt(task.description)
    
    // Generate plan using AI
    const planText = await this.generateCompletion(prompt)
    
    // Parse the plan from the generated text
    const plan = this.parsePlanFromText(planText, task.boardId)
    
    // Store the plan in the database
    this.createEntry(
      plansTable.id,
      task.id,
      DatabaseEntryType.DATA,
      'plan',
      plan,
      {
        mainGoal: plan.mainGoal,
        taskCount: plan.tasks.length
      }
    )
    
    // Create a summary of the plan
    const summary = `Created a plan with ${plan.tasks.length} tasks to achieve the goal: ${plan.mainGoal}`
    
    // Store the summary in the database
    this.createEntry(
      plansTable.id,
      task.id,
      DatabaseEntryType.TEXT,
      'summary',
      summary
    )
    
    // Return the planning result
    return {
      plan,
      summary
    }
  }

  /**
   * Create a prompt for the AI to generate a plan
   * @param query The user's query
   * @returns The prompt for the AI
   */
  private createPlanningPrompt(query: string): string {
    return `You are a Planning AI assistant that creates detailed work plans.
    
The user has asked for help with: "${query}"

Create a structured plan to accomplish this task effectively. The plan should include:
1. A clear main goal
2. Multiple tasks that need to be completed
3. Dependencies between tasks (which tasks depend on others)
4. The type of actor best suited for each task

Available actor types:
- RESEARCHER: For tasks involving information gathering, data collection, and knowledge compilation
- ANALYST: For tasks involving data analysis, insights generation, and summarization
- CODER: For tasks involving code generation, debugging, and technical implementation

For each task, include:
- A descriptive title (1-6 words)
- A detailed description of what needs to be done
- The actor type that should perform the task
- Dependencies (which tasks must be completed before this one)
- Priority (high, medium, or low)
- Estimated completion time (short, medium, or long)

Respond with a structured JSON format like this:
{
  "mainGoal": "Clear statement of the main objective",
  "tasks": [
    {
      "title": "Task Title",
      "description": "Detailed task description",
      "actorType": "RESEARCHER|ANALYST|CODER",
      "dependencies": [], // Empty for first tasks, or list of task numbers for dependent tasks
      "priority": "high|medium|low",
      "estimatedCompletion": "short|medium|long"
    },
    // Additional tasks...
  ]
}

Ensure that the plan is comprehensive, logical, and efficient. Tasks should build on each other where appropriate, with clear dependencies.`
  }

  /**
   * Parse a task plan from the generated text
   * @param planText The text generated by the AI
   * @param boardId The board ID to associate tasks with
   * @returns The parsed task plan
   */
  private parsePlanFromText(planText: string, boardId: string): TaskPlan {
    try {
      // Extract JSON from the response
      const jsonMatch = planText.match(/\{[\s\S]*\}/)
      if (!jsonMatch) {
        throw new Error('No valid JSON found in AI response')
      }

      const jsonPlan = JSON.parse(jsonMatch[0])
      
      // Validate the structure
      if (!jsonPlan.mainGoal || !Array.isArray(jsonPlan.tasks)) {
        throw new Error('Invalid plan structure')
      }

      // Process the tasks to ensure they have the correct actor types
      const processedTasks = jsonPlan.tasks.map((task: any) => {
        // Convert actor type string to enum
        let actorType = ActorType.RESEARCHER // Default
        
        if (task.actorType === 'RESEARCHER') {
          actorType = ActorType.RESEARCHER
        } else if (task.actorType === 'ANALYST') {
          actorType = ActorType.ANALYST
        } else if (task.actorType === 'CODER') {
          actorType = ActorType.CODER
        }

        return {
          title: task.title,
          description: task.description,
          actorType,
          dependencies: task.dependencies || [],
          priority: task.priority || 'medium',
          estimatedCompletion: task.estimatedCompletion || 'medium'
        }
      })

      return {
        mainGoal: jsonPlan.mainGoal,
        tasks: processedTasks
      }
    } catch (error: unknown) {
      console.error('Error parsing plan:', error)
      const errorMessage = error instanceof Error ? error.message : String(error)
      throw new Error(`Failed to parse the planning response: ${errorMessage}`)
    }
  }
} 