import { BaseActor } from './BaseActor'
import { ActorType, type VibeTask } from '@/types/vibe'
import { DatabaseEntryType } from '@/types/vibe'

/**
 * Result from the Reviewer actor
 */
export interface ReviewerResult {
  feedback: string
  suggestions: string[]
  quality: number // 0-10 quality score
  summary: string
}

/**
 * The Reviewer actor - responsible for providing feedback and evaluation
 */
export class Reviewer extends BaseActor {
  constructor() {
    super(ActorType.REVIEWER)
  }

  /**
   * Execute the Reviewer actor
   * @param task The review task
   * @returns The review result
   */
  protected async execute(task: VibeTask): Promise<ReviewerResult> {
    // Create a "reviews" table for storing review data
    const reviewsTable = this.createTable(
      task.boardId,
      'reviews',
      'Contains review feedback and evaluation data',
      {
        feedback: 'string',
        suggestions: 'array',
        quality: 'number',
        summary: 'string'
      }
    )
    
    // Create a prompt for the AI to generate a review
    const prompt = this.createReviewPrompt(task.description)
    
    // Generate review using AI
    const reviewText = await this.generateCompletion(prompt)
    
    // Parse the review from the generated text
    const review = this.parseReviewFromText(reviewText)
    
    // Store the review in the database
    this.createEntry(
      reviewsTable.id,
      task.id,
      DatabaseEntryType.DATA,
      'review',
      review,
      {
        quality: review.quality,
        suggestionCount: review.suggestions.length
      }
    )
    
    // Return the review result
    return review
  }

  /**
   * Create a prompt for the AI to generate a review
   * @param content The content to review
   * @returns The prompt for the AI
   */
  private createReviewPrompt(content: string): string {
    return `You are a critical Reviewer AI that excels at thorough evaluation and constructive feedback. You have expertise in identifying strengths, weaknesses, gaps, and opportunities for improvement in various types of content.

The user has requested a review of the following content:

"${content}"

Conduct a comprehensive review that:
1. Evaluates the overall quality, coherence, accuracy, and effectiveness
2. Identifies specific strengths that should be maintained
3. Highlights weaknesses, gaps, or areas that need improvement
4. Provides actionable suggestions for enhancement
5. Assigns a quality score on a scale of 0-10

Your review should be thorough yet concise, balanced, and constructive. Focus on providing feedback that is specific, actionable, and helps improve the quality of the content.

Respond with a structured JSON format exactly as follows:
{
  "feedback": "Detailed evaluation of the content covering its strengths and weaknesses",
  "suggestions": [
    "Specific, actionable suggestion for improvement",
    "Another specific suggestion",
    // Additional suggestions...
  ],
  "quality": 7, // Quality score on a scale of 0-10
  "summary": "Brief 1-2 sentence summary of the overall assessment"
}

Ensure your review is substantive, specific to the content provided, and offers genuinely helpful insights for improvement.`
  }

  /**
   * Parse a review from the generated text
   * @param reviewText The text generated by the AI
   * @returns The parsed review result
   */
  private parseReviewFromText(reviewText: string): ReviewerResult {
    try {
      // Extract JSON from the response
      const jsonMatch = reviewText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const review = JSON.parse(jsonMatch[0]);
        
        // Validate the structure
        if (review.feedback && Array.isArray(review.suggestions) && 
            typeof review.quality === 'number' && review.summary) {
          return {
            feedback: review.feedback,
            suggestions: review.suggestions,
            quality: Math.max(0, Math.min(10, review.quality)), // Ensure quality is between 0-10
            summary: review.summary
          };
        }
      }
      
      // Fallback if JSON parsing fails
      return this.createFallbackReview(reviewText);
    } catch (error) {
      console.error('Error parsing review:', error);
      return this.createFallbackReview(reviewText);
    }
  }
  
  /**
   * Create a fallback review if parsing fails
   * @param reviewText The original review text
   * @returns A structured review result
   */
  private createFallbackReview(reviewText: string): ReviewerResult {
    // Extract feedback (use first paragraph or entire text if short)
    const feedbackMatch = reviewText.match(/feedback:?\s*(.*?)(?=suggestions:|quality:|summary:|$)/is);
    const feedback = feedbackMatch ? feedbackMatch[1].trim() : reviewText.substring(0, 200);
    
    // Extract suggestions
    const suggestionsMatch = reviewText.match(/suggestions:?\s*(.*?)(?=quality:|summary:|$)/is);
    let suggestions: string[] = [];
    if (suggestionsMatch) {
      const suggestionText = suggestionsMatch[1];
      suggestions = suggestionText.split(/(?:\r\n|\r|\n|â€¢|-|\d+\.)/g)
        .map(s => s.trim())
        .filter(s => s.length > 0);
    }
    
    // Extract quality
    const qualityMatch = reviewText.match(/quality:?\s*(\d+(\.\d+)?)/i);
    const quality = qualityMatch ? Math.max(0, Math.min(10, parseFloat(qualityMatch[1]))) : 5;
    
    // Extract summary
    const summaryMatch = reviewText.match(/summary:?\s*(.*?)(?=$)/is);
    const summary = summaryMatch ? summaryMatch[1].trim() : "Review completed.";
    
    return {
      feedback,
      suggestions: suggestions.length > 0 ? suggestions : ["Improve clarity", "Add more detail"],
      quality,
      summary
    };
  }
} 