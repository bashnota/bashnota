import { BaseActor } from './BaseActor'
import { ActorType, type VibeTask } from '@/types/vibe'
import { DatabaseEntryType } from '@/types/vibe'
import { logger } from '@/services/logger'

/**
 * Visualization types supported by the Visualizer
 */
export type VisualizationType = 'chart' | 'diagram' | 'mermaid' | 'table' | 'latex'

/**
 * Result from the Visualizer actor
 */
export interface VisualizerResult {
  visualizations: Visualization[]
  summary: string
}

/**
 * A visualization created by the Visualizer
 */
export interface Visualization {
  type: VisualizationType
  title: string
  description: string
  content: string
}

/**
 * The Visualizer actor - responsible for creating visual representations
 */
export class Visualizer extends BaseActor {
  constructor() {
    super(ActorType.VISUALIZER)
  }

  /**
   * Execute the Visualizer actor
   * @param task The visualization task
   * @returns The visualization result
   */
  protected async execute(task: VibeTask): Promise<VisualizerResult> {
    // Create a "visualizations" table for storing visualization data
    const visualizationsTable = this.createTable(
      task.boardId,
      'visualizations',
      'Contains visualization data and metadata',
      {
        type: 'string',
        title: 'string',
        description: 'string',
        content: 'string'
      }
    )
    
    // Create a prompt for the AI to generate visualizations
    const prompt = this.createVisualizationPrompt(task.description)
    
    // Generate visualizations using AI
    const visualizationText = await this.generateCompletion(prompt)
    
    // Parse the visualizations from the generated text
    const result = this.parseVisualizationsFromText(visualizationText)
    
    // Store each visualization in the database
    result.visualizations.forEach((visualization, index) => {
      this.createEntry(
        visualizationsTable.id,
        task.id,
        DatabaseEntryType.DATA,
        `visualization_${index}`,
        visualization,
        {
          type: visualization.type,
          title: visualization.title
        }
      )
    })
    
    // Store the summary in the database
    this.createEntry(
      visualizationsTable.id,
      task.id,
      DatabaseEntryType.TEXT,
      'summary',
      result.summary
    )
    
    // Return the visualization result
    return result
  }

  /**
   * Create a prompt for the AI to generate visualizations
   * @param content The content to visualize
   * @returns The prompt for the AI
   */
  private createVisualizationPrompt(content: string): string {
    return `You are a specialized Visualization AI that excels at transforming data and concepts into clear, effective visual representations. You have expertise in data visualization, diagramming, and visual communication.

The user has requested visualizations for the following content:

"${content}"

Your task is to create appropriate visual representations that:
1. Clearly communicate the key information, relationships, or concepts
2. Use the most effective visualization types for the specific content
3. Are accompanied by clear titles and descriptions
4. Follow best practices in data visualization and visual design

Create 1-3 visualizations based on the content provided. Choose from the following visualization types based on what best suits the content:

1. Charts/Graphs: For quantitative data, trends, comparisons
2. Diagrams/Flowcharts: For processes, hierarchies, relationships
3. Tables: For structured data comparison
4. Mathematical Visualizations: For equations, mathematical concepts

For each visualization, provide:
- A clear, descriptive title
- A brief explanation of what the visualization shows
- The visualization content in an appropriate format:
  * For charts/graphs/diagrams: Use Mermaid syntax (https://mermaid-js.github.io/)
  * For tables: Use Markdown table syntax
  * For mathematical content: Use LaTeX syntax

Respond with a structured JSON format exactly as follows:
{
  "visualizations": [
    {
      "type": "chart|diagram|mermaid|table|latex", 
      "title": "Clear, descriptive title",
      "description": "Brief explanation of what this visualization shows",
      "content": "Mermaid, Markdown table, or LaTeX content"
    },
    // Additional visualizations...
  ],
  "summary": "Brief summary of the visualizations created and their key insights"
}

Ensure that:
- Your visualizations are accurate representations of the content
- The visualization types are appropriate for the data/concepts
- All syntax (Mermaid, Markdown, LaTeX) is valid and correctly formatted
- The visualizations provide meaningful insights or clarity`
  }

  /**
   * Parse visualizations from the generated text
   * @param visualizationText The text generated by the AI
   * @returns The parsed visualization result
   */
  private parseVisualizationsFromText(visualizationText: string): VisualizerResult {
    try {
      // Extract JSON from the response
      const jsonMatch = visualizationText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const result = JSON.parse(jsonMatch[0]);
        
        // Validate the structure
        if (Array.isArray(result.visualizations) && result.summary) {
          // Validate each visualization
          const validVisualizations = result.visualizations.filter((viz: any) => 
            viz.type && viz.title && viz.description && viz.content
          );
          
          if (validVisualizations.length > 0) {
            return {
              visualizations: validVisualizations,
              summary: result.summary
            };
          }
        }
      }
      
      // Fallback if JSON parsing fails
      return this.createFallbackVisualization(visualizationText);
    } catch (error) {
      logger.error('Error parsing visualizations:', error);
      return this.createFallbackVisualization(visualizationText);
    }
  }
  
  /**
   * Create a fallback visualization if parsing fails
   * @param visualizationText The original visualization text
   * @returns A structured visualization result
   */
  private createFallbackVisualization(visualizationText: string): VisualizerResult {
    // Try to extract visualization content based on common patterns
    const mermaidMatch = visualizationText.match(/```mermaid\s*([\s\S]*?)\s*```/);
    const latexMatch = visualizationText.match(/\$\$([\s\S]*?)\$\$/);
    const tableMatch = visualizationText.match(/\|[\s\S]*?\|[\s\S]*?\|/);
    
    const visualizations: Visualization[] = [];
    
    // If we found a mermaid diagram
    if (mermaidMatch) {
      visualizations.push({
        type: 'mermaid',
        title: 'Auto-generated Diagram',
        description: 'Diagram extracted from the visualization content',
        content: mermaidMatch[1].trim()
      });
    }
    
    // If we found a LaTeX equation
    if (latexMatch) {
      visualizations.push({
        type: 'latex',
        title: 'Mathematical Expression',
        description: 'Mathematical content extracted from the visualization',
        content: latexMatch[1].trim()
      });
    }
    
    // If we found a table
    if (tableMatch) {
      visualizations.push({
        type: 'table',
        title: 'Data Table',
        description: 'Tabular data extracted from the visualization content',
        content: tableMatch[0].trim()
      });
    }
    
    // If we didn't find any visualizations, create a simple fallback
    if (visualizations.length === 0) {
      visualizations.push({
        type: 'diagram',
        title: 'Simple Visualization',
        description: 'Basic representation of the content',
        content: `graph TD
    A[Main Concept] --> B[Key Point 1]
    A --> C[Key Point 2]
    B --> D[Detail 1]
    C --> E[Detail 2]`
      });
    }
    
    return {
      visualizations,
      summary: "Visualizations generated from the provided content."
    };
  }
} 